"""
Proxmox Metrics Viewer for Vobot Mini Dock
Displays VM/LXC counts and node metrics across two pages
"""
import lvgl as lv
import urequests as requests
import ujson
import utime

VERSION = "0.0.2"
__version__ = VERSION
NAME = "Proxmox"

# Default settings
PVE_HOST = "proxmox.home.lan:8006"
NODE_NAME = "proxmox"
API_TOKEN_ID = "api@pam!homepage"
API_SECRET = ""  # Must be configured via web settings
POLL_TIME = 10  # seconds between updates

# Globals
app_mgr = None
scr = None
label_title = None
label_page1 = None
label_page2 = None
current_page = 0  # 0 or 1
last_fetch_time = -999  # Force immediate first fetch

# Metrics storage (fixed size circular buffers)
HISTORY_SIZE = 32
lxc_running = 0
lxc_total = 0
vm_running = 0
vm_total = 0
cpu_history = []  # List of CPU fractions (0.0-1.0)
mem_history = []  # List of (used, total) tuples
netin_history = []  # List of bytes in
netout_history = []  # List of bytes out


def event_handler(e):
    """Handle encoder rotation for page navigation"""
    global current_page
    
    e_code = e.get_code()
    if e_code == lv.EVENT.KEY:
        e_key = e.get_key()
        # Debug: show key events for encoder/buttons without leaking other state
        print(f"[DBG] Key event: {e_key}")
        
        if e_key == lv.KEY.RIGHT:  # CCW = previous page
            current_page = (current_page - 1) % 2
            update_display()
            print(f"[DBG] ← Switched to page {current_page + 1}/2")
        elif e_key == lv.KEY.LEFT:  # CW = next page
            current_page = (current_page + 1) % 2
            update_display()
            print(f"[DBG] → Switched to page {current_page + 1}/2")
        elif e_key == lv.KEY.ENTER:  # Manual refresh
            # Debug: force immediate fetch on next foreground call
            print("[DBG] Manual refresh triggered")
            # Force immediate fetch on next foreground call
            global last_fetch_time
            last_fetch_time = -999
    elif e_code == lv.EVENT.FOCUSED:
        # Debug: ensure edit mode enabled for rotary encoder to work
        if not lv.group_get_default().get_editing():
            lv.group_get_default().set_editing(True)


def update_display():
    """Update UI based on current page"""
    global current_page, label_page1, label_page2
    print(f"[DBG] update_display() current_page={current_page}")
    
    if current_page == 0:
        # Page 1: Counts and summary
        if label_page1:
            label_page1.clear_flag(lv.obj.FLAG.HIDDEN)
        if label_page2:
            label_page2.add_flag(lv.obj.FLAG.HIDDEN)
        # Hide gauges container if it exists
        if hasattr(update_page2, '_gauge_container'):
            update_page2._gauge_container.add_flag(lv.obj.FLAG.HIDDEN)
        update_page1()
    else:
        # Page 2: Graphs
        if label_page1:
            label_page1.add_flag(lv.obj.FLAG.HIDDEN)
        if label_page2:
            label_page2.add_flag(lv.obj.FLAG.HIDDEN)
        # Show gauges container
        if hasattr(update_page2, '_gauge_container'):
            update_page2._gauge_container.clear_flag(lv.obj.FLAG.HIDDEN)
        update_page2()


def update_page1():
    """Update page 1 with counts and node summary"""
    global label_page1, lxc_running, lxc_total, vm_running, vm_total
    global cpu_history, mem_history
    print(f"[DBG] update_page1() lxc={lxc_running}/{lxc_total} vm={vm_running}/{vm_total} cpu_samples={len(cpu_history)} mem_samples={len(mem_history)}")
    
    # Get latest CPU and memory values
    cpu_pct = int(cpu_history[-1] * 100) if cpu_history else 0
    mem_used_gb = 0
    mem_total_gb = 0
    if mem_history:
        mem_used, mem_total = mem_history[-1]
        mem_used_gb = mem_used / (1024**3)  # bytes to GB
        mem_total_gb = mem_total / (1024**3)
    print(f"[DBG] Computed cpu_pct={cpu_pct} mem_used_gb={mem_used_gb:.2f} mem_total_gb={mem_total_gb:.2f}")
    
    text = f"LXC: {lxc_running}/{lxc_total} running\n"
    text += f"VM:  {vm_running}/{vm_total} running\n\n"
    text += f"Node: {NODE_NAME}\n"
    text += f"CPU: {cpu_pct}%\n"
    text += f"RAM: {mem_used_gb:.1f}/{mem_total_gb:.1f} GB"
    
    if label_page1:
        label_page1.set_text(text)


def draw_gauge(parent, x, y, radius, pct, label_text, color_hex):
    """Draw a circular arc gauge (simplified)"""
    try:
        # Create container for gauge
        gauge_obj = lv.obj(parent)
        gauge_obj.set_pos(x, y)
        gauge_obj.set_size(radius * 2, radius * 2 + 20)
        gauge_obj.set_style_bg_color(lv.color_hex(0x000000), lv.PART.MAIN)
        gauge_obj.set_style_bg_opa(lv.OPA.TRANSP, lv.PART.MAIN)
        gauge_obj.set_style_border_width(0, lv.PART.MAIN)
        gauge_obj.set_style_pad_all(0, lv.PART.MAIN)
        
        # Draw outer circle (background)
        circle = lv.obj(gauge_obj)
        circle.set_size(radius * 2, radius * 2)
        circle.set_style_bg_color(lv.color_hex(0x1a1a2e), lv.PART.MAIN)
        circle.set_style_radius(lv.RADIUS.CIRCLE, lv.PART.MAIN)
        circle.set_style_border_width(2, lv.PART.MAIN)
        circle.set_style_border_color(lv.color_hex(0x444466), lv.PART.MAIN)
        circle.center()
        
        # Draw filled arc (progress indicator)
        arc = lv.arc(gauge_obj)
        arc.set_size(radius * 2 - 8, radius * 2 - 8)
        arc.set_bg_angles(0, 360)
        arc.set_angles(0, int(pct * 3.6))  # 360 degrees = 100%
        arc.set_style_arc_color(lv.color_hex(color_hex), lv.PART.INDICATOR)
        arc.set_style_arc_width(6, lv.PART.INDICATOR)
        arc.set_style_arc_color(lv.color_hex(0x333333), lv.PART.MAIN)
        arc.set_style_arc_width(6, lv.PART.MAIN)
        arc.center()
        
        # Percentage text in center
        label = lv.label(gauge_obj)
        label.set_text(f"{int(pct)}%")
        label.set_style_text_font(lv.font_default(), lv.PART.MAIN)
        label.set_style_text_color(lv.color_hex(color_hex), lv.PART.MAIN)
        label.center()
        
        # Label below
        label_bottom = lv.label(gauge_obj)
        label_bottom.set_text(label_text)
        label_bottom.set_style_text_font(lv.font_default(), lv.PART.MAIN)
        label_bottom.set_style_text_color(lv.color_hex(0xCCCCCC), lv.PART.MAIN)
        label_bottom.align(lv.ALIGN.BOTTOM_MID, 0, 2)
        
        return gauge_obj
    except Exception as e:
        print(f"Gauge draw error: {e}")
        return None


def update_page2():
    """Update page 2 with graphical gauges"""
    global label_page2, cpu_history, mem_history, netin_history, netout_history
    global current_page, scr
    
    # On page 2, we draw gauges instead of using label text
    if current_page != 1:
        return
    
    try:
        # Clear old gauges if they exist
        if hasattr(update_page2, '_gauges'):
            for g in update_page2._gauges:
                if g:
                    g.delete()
        update_page2._gauges = []
        
        if not scr:
            return
        
        # Get current values
        cpu_pct = (cpu_history[-1] * 100) if cpu_history else 0
        mem_pct = 0
        if mem_history:
            mem_used, mem_total = mem_history[-1]
            mem_pct = (mem_used / mem_total * 100) if mem_total else 0
        
        # Network: show recent bytes (scale for visibility)
        netin_latest = netin_history[-1] if netin_history else 0
        netout_latest = netout_history[-1] if netout_history else 0
        # Normalize to 0-100% based on reasonable threshold (1GB)
        netin_pct = min(100, (netin_latest / (1024**3)) * 100)
        netout_pct = min(100, (netout_latest / (1024**3)) * 100)
        
        # Create a container for gauges if not already there
        if not hasattr(update_page2, '_gauge_container'):
            gauge_cont = lv.obj(scr)
            gauge_cont.set_pos(0, 35)
            gauge_cont.set_size(320, 230)
            gauge_cont.set_style_bg_color(lv.color_hex(0x000000), lv.PART.MAIN)
            gauge_cont.set_style_bg_opa(lv.OPA.TRANSP, lv.PART.MAIN)
            gauge_cont.set_style_border_width(0, lv.PART.MAIN)
            gauge_cont.set_style_pad_all(0, lv.PART.MAIN)
            update_page2._gauge_container = gauge_cont
        else:
            gauge_cont = update_page2._gauge_container
        
        # Draw 4 gauges in a 2x2 grid
        # Top-left: CPU
        cpu_gauge = draw_gauge(gauge_cont, 10, 10, 30, cpu_pct, "CPU", 0xFF6B6B)
        if cpu_gauge:
            update_page2._gauges.append(cpu_gauge)
        
        # Top-right: Memory
        mem_gauge = draw_gauge(gauge_cont, 170, 10, 30, mem_pct, "Memory", 0x4ECDC4)
        if mem_gauge:
            update_page2._gauges.append(mem_gauge)
        
        # Bottom-left: Network In
        netin_gauge = draw_gauge(gauge_cont, 10, 120, 30, netin_pct, "Net In", 0x45B7D1)
        if netin_gauge:
            update_page2._gauges.append(netin_gauge)
        
        # Bottom-right: Network Out
        netout_gauge = draw_gauge(gauge_cont, 170, 120, 30, netout_pct, "Net Out", 0xFFA502)
        if netout_gauge:
            update_page2._gauges.append(netout_gauge)
        
    except Exception as e:
        print(f"Page 2 update error: {e}")
        if label_page2:
            label_page2.set_text(f"Graph error: {str(e)[:30]}")


async def on_boot(apm):
    """Called when app is first loaded - store app manager"""
    global app_mgr
    app_mgr = apm
    print(f"=== Proxmox on_boot() === app_mgr: {app_mgr}")


async def on_start():
    """Called when app starts - set up UI and load config"""
    global scr, label_title, label_page1, label_page2
    global PVE_HOST, NODE_NAME, API_TOKEN_ID, API_SECRET, POLL_TIME
    
    print("[DBG] === Proxmox on_start() ===")
    
    try:
        scr = lv.obj()
        scr.set_style_bg_color(lv.color_hex(0x000000), lv.PART.MAIN)
        scr.set_style_bg_opa(lv.OPA.COVER, lv.PART.MAIN)
        
        # Load persisted settings
        global PVE_HOST, NODE_NAME, API_TOKEN_ID, API_SECRET, POLL_TIME
        try:
            if app_mgr:
                cfg = app_mgr.config() if hasattr(app_mgr, "config") else {}
                # Debug: don't print secrets; show presence and lengths
                safe_cfg = dict(cfg) if isinstance(cfg, dict) else {}
                if isinstance(safe_cfg, dict) and "api_secret" in safe_cfg:
                    safe_cfg["api_secret"] = f"<len={len(safe_cfg['api_secret'])}>" if safe_cfg["api_secret"] else "<empty>"
                print(f"[DBG] Config loaded: {safe_cfg}")
                if isinstance(cfg, dict):
                    # pve_host
                    host = cfg.get("pve_host")
                    if isinstance(host, str) and host:
                        PVE_HOST = host
                        print(f"[DBG] ✓ Host set to: {PVE_HOST}")
                    else:
                        print(f"[DBG] ✗ pve_host not in config, using default: {PVE_HOST}")
                    # node_name
                    node = cfg.get("node_name")
                    if isinstance(node, str) and node:
                        NODE_NAME = node
                        print(f"[DBG] ✓ Node set to: {NODE_NAME}")
                    else:
                        print(f"[DBG] ✗ node_name not in config, using default: {NODE_NAME}")
                    # api_token_id
                    token_id = cfg.get("api_token_id")
                    if isinstance(token_id, str) and token_id:
                        API_TOKEN_ID = token_id
                        print(f"[DBG] ✓ Token ID set")
                    else:
                        print(f"[DBG] ✗ api_token_id not in config")
                    # api_secret - CRITICAL!
                    secret = cfg.get("api_secret")
                    if isinstance(secret, str) and secret:
                        API_SECRET = secret
                        # Security: never print secret value; only its length
                        print(f"[DBG] ✓ API Secret configured (len={len(secret)})")
                    else:
                        print(f"[DBG] ✗ api_secret NOT in config - authentication will fail!")
                    # poll_time
                    poll = cfg.get("poll_time")
                    if poll:
                        try:
                            poll = int(poll)
                            if 5 <= poll <= 120:
                                POLL_TIME = poll
                                print(f"[DBG] ✓ Poll time set to: {POLL_TIME}s")
                            else:
                                print(f"[DBG] ✗ poll_time out of range (5-120), using default: {POLL_TIME}s")
                        except (ValueError, TypeError):
                            print(f"[DBG] ✗ poll_time invalid, using default: {POLL_TIME}s")
                    else:
                        print(f"[DBG] ✗ poll_time not in config, using default: {POLL_TIME}s")
            else:
                print("[DBG] ✗ app_mgr is None - settings won't load!")
        except Exception as e:
            print(f"[DBG] ✗ Config load error: {e}")
        
        # Title bar
        label_title = lv.label(scr)
        label_title.set_text(f"Proxmox: {NODE_NAME}")
        label_title.set_pos(10, 8)
        label_title.set_style_text_color(lv.color_hex(0x00FF88), lv.PART.MAIN)
        
        # Separator line
        line_points = [{"x": 10, "y": 32}, {"x": 310, "y": 32}]
        separator_line = lv.line(scr)
        separator_line.set_points(line_points, len(line_points))
        separator_line.set_style_line_width(2, 0)
        separator_line.set_style_line_color(lv.color_hex(0x4488FF), 0)
        
        # Page 1 content (counts and summary)
        label_page1 = lv.label(scr)
        label_page1.set_text("Loading...")
        label_page1.set_pos(10, 40)
        label_page1.set_width(300)
        label_page1.set_style_text_color(lv.color_hex(0xFFFFFF), lv.PART.MAIN)
        label_page1.set_long_mode(lv.label.LONG.WRAP)
        
        # Page 2 content (graphs)
        label_page2 = lv.label(scr)
        label_page2.set_text("Loading graphs...")
        label_page2.set_pos(10, 40)
        label_page2.set_width(300)
        label_page2.set_style_text_color(lv.color_hex(0xFFFFFF), lv.PART.MAIN)
        label_page2.set_long_mode(lv.label.LONG.WRAP)
        label_page2.add_flag(lv.obj.FLAG.HIDDEN)  # Hidden initially
        
        # Initialize gauge container (hidden initially)
        gauge_cont = lv.obj(scr)
        gauge_cont.set_pos(0, 35)
        gauge_cont.set_size(320, 230)
        gauge_cont.set_style_bg_color(lv.color_hex(0x000000), lv.PART.MAIN)
        gauge_cont.set_style_bg_opa(lv.OPA.TRANSP, lv.PART.MAIN)
        gauge_cont.set_style_border_width(0, lv.PART.MAIN)
        gauge_cont.set_style_pad_all(0, lv.PART.MAIN)
        gauge_cont.add_flag(lv.obj.FLAG.HIDDEN)
        update_page2._gauge_container = gauge_cont
        
        lv.scr_load(scr)
        print("[DBG] Screen loaded; adding events & focus group")
        
        # Attach event handler
        scr.add_event(event_handler, lv.EVENT.ALL, None)
        group = lv.group_get_default()
        if group:
            group.add_obj(scr)
            lv.group_focus_obj(scr)
            group.set_editing(True)
            print("[DBG] Focus group ready & editing enabled")
        else:
            print("[DBG] WARNING: lv.group_get_default() returned None")
        
        print("[DBG] UI ready")
        # Initial render so the user sees content immediately
        try:
            update_display()
            print("[DBG] Initial update_display() called")
        except Exception as e:
            print(f"[DBG] Initial display update failed: {e}")
        
    except Exception as e:
        print(f"ERROR in on_start: {e}")


async def on_running_foreground():
    """Called every ~200ms - fetch metrics here"""
    global last_fetch_time, label_title
    global lxc_running, lxc_total, vm_running, vm_total
    global cpu_history, mem_history, netin_history, netout_history
    
    now = utime.time()
    # Throttle polling
    if now - last_fetch_time < POLL_TIME:
        return
    last_fetch_time = now
    print(f"[DBG] Fetching metrics at {now} (poll={POLL_TIME}s)...")

    # Require secret
    if not API_SECRET:
        print("[DBG] ERROR: API_SECRET not configured")
        if label_title:
            label_title.set_style_text_color(lv.color_hex(0xFF4444), lv.PART.MAIN)
        if label_page1:
            label_page1.set_text("ERROR: API token not configured.\nPlease set up via web interface.")
        return

    # Prepare auth
    auth_header = {"Authorization": f"PVEAPIToken={API_TOKEN_ID}={API_SECRET}"}
    base_url = f"https://{PVE_HOST}/api2/json"
    if not API_TOKEN_ID:
        print("[DBG] ERROR: API_TOKEN_ID not configured")
        return
    print(f"[DBG] ✓ Auth ready: token_id={API_TOKEN_ID}, host={PVE_HOST}, node={NODE_NAME}")

    try:
        # Fetch VM & LXC counts in one lightweight call via cluster resources
        try:
            url = f"{base_url}/cluster/resources?type=vm"
            print(f"[DBG] GET {url}")
            response = requests.get(url, headers=auth_header, timeout=8)
            status = response.status_code
            if status == 200:
                data = ujson.loads(response.text).get('data', [])
                # Count QEMU VMs
                vm_items = [v for v in data if v.get('type') == 'qemu' and v.get('node') == NODE_NAME]
                vm_total = len(vm_items)
                vm_running = sum(1 for v in vm_items if v.get('status') == 'running')
                # Count LXC containers
                lxc_items = [c for c in data if c.get('type') == 'lxc' and c.get('node') == NODE_NAME]
                lxc_total = len(lxc_items)
                lxc_running = sum(1 for c in lxc_items if c.get('status') == 'running')
                print(f"[DBG] LXC: {lxc_running}/{lxc_total} | VM: {vm_running}/{vm_total}")
            else:
                print(f"[DBG] VM/LXC fetch error: {status}")
            response.close()
        except Exception as e:
            print(f"[DBG] VM/LXC fetch exception: {e}")

        # Small delay to avoid back-to-back TLS requests overwhelming the stack
        try:
            utime.sleep_ms(100)
        except Exception:
            pass

        # Node metrics
        try:
            url = f"{base_url}/cluster/resources?type=node"
            print(f"[DBG] GET {url}")
            response = requests.get(url, headers=auth_header, timeout=8)
            status = response.status_code
            if status == 200:
                data = ujson.loads(response.text).get('data', [])
                node_data = None
                for n in data:
                    if n.get('node') == NODE_NAME:
                        node_data = n
                        break
                if node_data:
                    cpu = node_data.get('cpu', 0)
                    mem_used = node_data.get('mem', 0)
                    mem_total = node_data.get('maxmem', 1)
                    netin = node_data.get('netin', 0)
                    netout = node_data.get('netout', 0)

                    cpu_history.append(cpu)
                    mem_history.append((mem_used, mem_total))
                    netin_history.append(netin)
                    netout_history.append(netout)
                    if len(cpu_history) > HISTORY_SIZE:
                        cpu_history.pop(0)
                    if len(mem_history) > HISTORY_SIZE:
                        mem_history.pop(0)
                    if len(netin_history) > HISTORY_SIZE:
                        netin_history.pop(0)
                    if len(netout_history) > HISTORY_SIZE:
                        netout_history.pop(0)
                    print(f"[DBG] Node metrics: cpu={cpu*100:.1f}% mem={mem_used}/{mem_total} net in/out={netin}/{netout}")
                else:
                    print("[DBG] Node not found in resources")
            else:
                print(f"[DBG] Cluster fetch error: {status}")
            response.close()
        except Exception as e:
            print(f"[DBG] Cluster fetch exception: {e}")

        # Success styling and refresh
        if label_title:
            label_title.set_style_text_color(lv.color_hex(0x00FF88), lv.PART.MAIN)
        update_display()

    except Exception as e:
        print(f"[DBG] Fetch failed: {e}")
        if label_title:
            label_title.set_style_text_color(lv.color_hex(0xFF4444), lv.PART.MAIN)
        if label_page1:
            label_page1.set_text(f"Error: {str(e)[:40]}")


async def on_stop():
    """Called when leaving app"""
    global scr
    print("Proxmox stopping")
    if scr:
        scr.clean()
        del scr
        scr = None


def get_settings_json():
    """Return JSON for web settings form - called by Vobot system"""
    return {
        "title": "Proxmox Configuration",
        "form": [
            {
                "type": "input",
                "default": "proxmox.home.lan:8006",
                "caption": "Proxmox Host",
                "name": "pve_host",
                "attributes": {"maxLength": 100, "placeholder": "proxmox.home.lan:8006"},
                "tip": "Hostname:port of Proxmox server"
            },
            {
                "type": "input",
                "default": "proxmox",
                "caption": "Node Name",
                "name": "node_name",
                "attributes": {"maxLength": 50, "placeholder": "proxmox"},
                "tip": "Name of the Proxmox node to monitor"
            },
            {
                "type": "input",
                "default": "api@pam!homepage",
                "caption": "API Token ID",
                "name": "api_token_id",
                "attributes": {"maxLength": 100, "placeholder": "user@realm!tokenname"},
                "tip": "API token ID (user@realm!tokenname)"
            },
            {
                "type": "input",
                "default": "",
                "caption": "API Secret",
                "name": "api_secret",
                "attributes": {"maxLength": 100, "placeholder": "secret-uuid-here"},
                "tip": "API token secret (UUID)"
            },
            {
                "type": "input",
                "default": "10",
                "caption": "Poll Interval (seconds)",
                "name": "poll_time",
                "attributes": {"maxLength": 3, "placeholder": "10"},
                "tip": "How often to fetch metrics (5-120 seconds)"
            }
        ]
    }
